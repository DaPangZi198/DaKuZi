// Edraw Max.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <windows.h>
#include <openssl/rsa.h>


#pragma comment(lib,"libeay32.lib")


const char * pbN = "F77A4F4837E8EE63C1640CBC9614FFFB1B39FD768E17F5741E464440FCE376F979D531B5D92DA3B0AEBFD935EC48A0C72EE9C3F09E5F77976417BD65C2C12E47C1F45C51A69A436CD88AEC21759816C9BF0017A336027D4B417DCAFF4BB39E697E66BCC3EC8913B229FC757F0C1387BF8D121205E0326AEDC3F3005C5D58402B";
const char * pbD = "F0060D9D22B4E5799518FF8D6D16E30B5DE5C9A251C0850CE14C0F68E49D8D47FBD53DC87CE25A0FC3FD48A3970EFDF911D422795E7183612EF0237EEDFC456FE52A23BCC44348C3F57856074854F4A404D6FF37F2112C3BF6CBF5E383DEF20C6D49DD328A5CF06309A10EFBDF6EC20819A55B20556FAF2DBB820FBE3A4CE8A1";
const char * pbE = "10001";
BIGNUM *bN = new BIGNUM();
BIGNUM *bD = new BIGNUM();
BIGNUM *bE = new BIGNUM();



unsigned char EncryptText[0x0080] =
{
	0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x39, 0x31, 0x61, 0x66, 0x37, 0x31, 0x62, 0x67, 0x38, 0x31

};


int _tmain(int argc, _TCHAR* argv[])
{
	RSA* Rsa = RSA_generate_key(1024, RSA_F4, 0, 0);
	BN_hex2bn(&bD, pbD);
	BN_hex2bn(&bN, pbN);
	BN_hex2bn(&bE, pbE);
	Rsa->n = bN;  // 模数
	Rsa->d = bD;  // 私钥
	Rsa->e = bE;  // 
	int len = RSA_size(Rsa);
	BYTE* CipherText = new BYTE[len];




	memset(CipherText, 0, len);
	// 数据长度、数据、outbuf、RSA、填充类型
	RSA_private_encrypt(0x80, (unsigned char *)EncryptText, CipherText, Rsa, RSA_NO_PADDING);//RSA_PKCS1_PADDING   RSA_NO_PADDING);
	char out1[0x80] = { 0 };
	RSA_public_decrypt(len, CipherText, (unsigned char *)out1, Rsa, RSA_NO_PADDING);//RSA_PKCS1_PADDING RSA_NO_PADDING );



	RSA_free(Rsa);
	delete[]CipherText;
	return 0;
}

